for any ordered bytes, they are converted to little endian for disk or network
sstable:
[(block_len, [(key_len as u64, key, value_len as u64, value)])] <- datablocks
num bytes for sparse index
[(key_len as u64, key)] <- sparse index
byte encoding for bloom filter
sstable footer:
8 bytes byte offset for sparse index
8 bytes byte offset for bloom filter
8 bytes number of (unique) keys in file

The index is placed after the datablocks to simplify compaction implementation.
This seems similar to the rocksdb implementation. 

wal:
1 byte operation 4 byte key length [key] 4 byte value length [value] for each walentry